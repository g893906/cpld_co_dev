//////////////////////////////////////////////////////////////////////////////////////////////
//
// Verilog file generated by X-HDL - Revision 3.2.52  Mar. 28, 2005 
// Fri Jul 13 21:42:39 2012
//
//      Input file         : E:/240CPLD/02_interface/TLC5615_OK/spidac.vhd
//      Design name        : spidac
//      Author             : 
//      Company            : 
//
//      Description        : 
//
//
//////////////////////////////////////////////////////////////////////////////////////////////
//
module spidac (clk, Reset, dac_sclk, DAC_nCS, dac_din);

   input clk; 
   input Reset; 
   output dac_sclk; 
   wire dac_sclk;
   output DAC_nCS; 
   wire DAC_nCS;
   output dac_din; 
   wire dac_din;

   reg[11:0] shift_reg; 
   parameter[11:0] DAC_HIGH = 12'b111111111100; 
   parameter[11:0] DAC_LOW = 12'b111011111000; 
   reg loadH; 
   reg[3:0] state; 
   parameter[3:0] IDLE = 4'b0010; 
   parameter[3:0] LOAD = 4'b0110; 
   parameter[3:0] CSDAC = 4'b0000; 
   parameter[3:0] TxD0 = 4'b0001; 
   parameter[3:0] TxD1 = 4'b0101; 
   parameter[3:0] TXD2 = 4'b0100; 
   parameter[3:0] shift = 4'b1000; 
   parameter[3:0] spiend1 = 4'b1100; 
   parameter[3:0] spiend2 = 4'b1010; 
   reg wait_on; 
   reg[2:0] wait_cnt; 
   reg clkdiv2; 
   reg clkdiv4; 
   reg[3:0] bit_cnt; 

   always @(clk or Reset)
   begin
      if (Reset == 1'b0)
      begin
         clkdiv2 <= 1'b0 ; 
      end
      else if (clk == 1'b1)
      begin
         clkdiv2 <= ~clkdiv2 ; 
      end 
   end 

   always @(clkdiv2 or Reset)
   begin
      if (Reset == 1'b0)
      begin
         clkdiv4 <= 1'b0 ; 
      end
      else if (clkdiv2 == 1'b1)
      begin
         clkdiv4 <= ~clkdiv4 ; 
      end 
   end 

   always @(Reset or clkdiv4)
   begin
      if (Reset == 1'b0)
      begin
         bit_cnt <= 4'b0000 ; 
         state <= IDLE ; 
         loadH <= 1'b1 ; 
         wait_on <= 1'b0 ; 
      end
      else if (clkdiv4 == 1'b1)
      begin
         case (state)
            IDLE :
                     begin
                        state <= LOAD ; 
                     end
            LOAD :
                     begin
                        state <= CSDAC ; 
                        bit_cnt <= 4'b0000 ; 
                        if (loadH == 1'b1)
                        begin
                           shift_reg <= DAC_HIGH ; 
                        end
                        else
                        begin
                           shift_reg <= DAC_LOW ; 
                        end 
                     end
            CSDAC :
                     begin
                        state <= TxD0 ; 
                     end
            TxD0 :
                     begin
                        state <= TxD1 ; 
                        bit_cnt <= bit_cnt + 1 ; 
                     end
            TxD1 :
                     begin
                        state <= shift ; 
                     end
            shift :
                     begin
                        state <= TXD2 ; 
                        begin : xhdl_6
                           integer i;
                           for(i = 11; i >= 1; i = i - 1)
                           begin
                              shift_reg[i] <= shift_reg[i - 1] ; 
                           end
                        end 
                        shift_reg[0] <= 1'b0 ; 
                     end
            TXD2 :
                     begin
                        if (bit_cnt == 4'b1100)
                        begin
                           state <= spiend1 ; 
                        end
                        else
                        begin
                           state <= TxD0 ; 
                        end 
                     end
            spiend1 :
                     begin
                        state <= spiend2 ; 
                        wait_on <= 1'b1 ; 
                     end
            spiend2 :
                     begin
                        if (wait_cnt == 3'b111)
                        begin
                           state <= LOAD ; 
                           wait_on <= 1'b0 ; 
                           loadH <= ~loadH ; 
                        end 
                     end
            default :
                     begin
                        state <= IDLE ; 
                     end
         endcase 
      end 
   end 

   always @(Reset or wait_on or clkdiv4)
   begin
      if (Reset == 1'b0)
      begin
         wait_cnt <= 3'b000 ; 
      end
      else if (clkdiv4 == 1'b0)
      begin
         if (wait_on == 1'b1)
         begin
            wait_cnt <= wait_cnt + 1 ; 
         end
         else
         begin
            wait_cnt <= 3'b000 ; 
         end 
      end 
   end 
   assign dac_din = shift_reg[11] ;
   assign dac_sclk = state[0] ;
   assign DAC_nCS = state[1] ;
endmodule
